# 设计模式列表

## GOF 23个模式

### 创建型

用来创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。（5个）

- 单例模式： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。[Singleton](Singleton.md)
- 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。[Factory Method](Factory-Method.md) [Simple Factory](Simple-Factory.md)
- 抽象工厂模式：提供一个接口，用于创建相关或相互依赖对象的家族，而不需要明确指定具体类。[Abstract Factory](Abstract-Factory.md)
- 构建器模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。[Builder](Builder.md)
- 原型模式： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。[Prototype](Prototype.md)

### 结构型

处理类或对象的组合；描述如何将类或对象结合在一起形成更大的结构，解决模块之间的耦合关系。（7个）

- 适配器模式: 将一个类的接口转换成另外一个客户希望的接口。[Adapter](Adapter.md)
- 外观模式: 为子系统中的一组接口提供一个一致的界面。[Facade](Facade.md)
- 装饰模式: 动态地给一个对象添加一些额外的职责。[Decorator](Decorator.md)
- 代理模式: 为其他对象提供一种代理以控制对这个对象的访问。[Proxy](Proxy.md)
- 组合模式: 将对象组合成树形结构以表示“部分-整体”的层次结构。组合能让客户以一致的方式处理个别对象及组合对象。[Composit](Composit.md)
- 桥接模式: 将抽象部分与它的实现部分分离,使它们都可以独立地变化。[Bridge](Bridge.md)
- 享元模式: 运用共享技术有效地支持大量细粒度的对象。[FlyWeight](FlyWeight.md)

### 行为型

对类或对象怎样交互和怎样分配职责进行描述。（11个）

- 策略模式: 定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。[Strategy](Strategy.md)
- 状态模式: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。[State](State.md)
- 观察者模式: 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。[Observer](Observer.md)
- 命令模式: 将一个命令封装为一个对象，从而使你可用不同的命令对客户进行参数化。[Command](Command.md)
- 模版方法模式: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。[Template Method](Template-Method.md)
- 迭代器模式: 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。[Iterator](Iterator.md)
- 解释器模式: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。[Interpreter](Interpreter.md)
- 中介者模式: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[Mediator](Mediator.md)
- 备忘录模式: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。[Memento](Memento.md)
- 职责链模式: 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。[Chain of Responsibility](Chain-of-Responsibility.md)
- 访问者模式: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。[Visitor](Visitor.md)

## 其他常见模式

- [MVC](MVC.md)

- [MVVM](MVVM.md)

- [DI](DI.md)